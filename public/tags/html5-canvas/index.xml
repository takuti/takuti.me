<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Html5 Canvas on takuti.me</title>
    <link>http://localhost:1313/tags/html5-canvas/</link>
    <description>Recent content in Html5 Canvas on takuti.me</description>
    <generator>Hugo -- gohugo.io</generator>
    <lastBuildDate>Sun, 08 Dec 2013 00:00:00 +0000</lastBuildDate>
    <atom:link href="http://localhost:1313/tags/html5-canvas/index.xml" rel="self" type="application/rss+xml" />
    
    <item>
      <title>Poisson Image Editingでいい感じの画像合成ができるやつを作る on Web</title>
      <link>http://localhost:1313/note/poisson-image-blending/</link>
      <pubDate>Sun, 08 Dec 2013 00:00:00 +0000</pubDate>
      
      <guid>http://localhost:1313/note/poisson-image-blending/</guid>
      <description>&lt;p&gt;&lt;a href=&#34;http://atnd.org/events/45075&#34;&gt;Aizu Advent Calendar 2013&lt;/a&gt; 8日目の記事です。&lt;/p&gt;
&lt;h3&gt;デモ&lt;/h3&gt;
&lt;p&gt;まずは作ったやつ（デモ版）からどうぞ。&lt;br /&gt;
【 &lt;strong&gt;&lt;a href=&#34;http://takuti.me/dev/poisson/demo/&#34;&gt;Poisson Image Blending - Demo&lt;/a&gt;&lt;/strong&gt; 】&lt;/p&gt;
&lt;p&gt;&lt;!--more--&gt;&lt;/p&gt;
&lt;p&gt;Step1はいじらなくていいので、Step2で適当にマスク領域を塗ってあげてください。&lt;br /&gt;
&lt;img src=&#34;http://localhost:1313/images/wp/Screen-Shot-2013-12-08-at-12.41.01-AM.png&#34; alt=&#34;Screen Shot 2013-12-08 at 12.41.01 AM&#34; width=&#34;186&#34; height=&#34;271&#34; class=&#34;alignnone size-full wp-image-294&#34; /&gt;&lt;br /&gt;
こんな感じで塗れたら、&lt;strong&gt;HERE&lt;/strong&gt;ボタンをクリック。するとStep3にマスクをかけた領域だけ乗っかります。&lt;br /&gt;
&lt;img src=&#34;http://localhost:1313/images/wp/Screen-Shot-2013-12-08-at-12.43.06-AM.png&#34; alt=&#34;Screen Shot 2013-12-08 at 12.43.06 AM&#34; width=&#34;287&#34; height=&#34;275&#34; class=&#34;alignnone size-full wp-image-295&#34; /&gt;&lt;br /&gt;
そうしたら矢印ボタンで位置を調整して、&lt;br /&gt;
&lt;img src=&#34;http://localhost:1313/images/wp/Screen-Shot-2013-12-08-at-12.44.40-AM.png&#34; alt=&#34;Screen Shot 2013-12-08 at 12.44.40 AM&#34; width=&#34;282&#34; height=&#34;283&#34; class=&#34;alignnone size-full wp-image-296&#34; /&gt;&lt;br /&gt;
「ここで合成だー」と思ったところで&lt;strong&gt;OK&lt;/strong&gt;ボタンをクリックすれば、&lt;br /&gt;
&lt;img src=&#34;http://localhost:1313/images/wp/Screen-Shot-2013-12-08-at-12.44.51-AM.png&#34; alt=&#34;Screen Shot 2013-12-08 at 12.44.51 AM&#34; width=&#34;286&#34; height=&#34;283&#34; class=&#34;alignnone size-full wp-image-297&#34; /&gt;&lt;br /&gt;
真顔モナリザの完成です。&lt;/p&gt;
&lt;p&gt;このようにいい感じの画像合成ができる手法は、ググればC++やPython、さらにHTML5 Canvasでの実装もすでに存在します。ま、まぁマスク領域自分で塗れるようにしたから新規性あるよね・・・。&lt;/p&gt;
&lt;h3&gt;アプリ版&lt;/h3&gt;
&lt;p&gt;デモを利用して、合成したい2枚の画像を自分で選べるものを作りました。アプリ版です。&lt;br /&gt;
【 &lt;strong&gt;&lt;a href=&#34;http://takuti.me/dev/poisson/app/&#34;&gt;Poisson Image Blending - App&lt;/a&gt;&lt;/strong&gt; 】&lt;/p&gt;
&lt;p&gt;まずは&lt;strong&gt;ベース画像（合成先）&lt;/strong&gt;と&lt;strong&gt;ソース画像（切り抜いて合成する方）&lt;/strong&gt;をそれぞれ選択します。画像サイズはいずれも150ピクセル×150ピクセルに限定しています。それより大きい/小さい画像を選択すると縮小/拡大されます。&lt;/p&gt;
&lt;p&gt;ちゃんと両方選択できると、&lt;strong&gt;Start App&lt;/strong&gt;ボタンが有効になるのでクリック。&lt;br /&gt;
&lt;img src=&#34;http://localhost:1313/images/wp/Screen-Shot-2013-12-08-at-7.26.53-AM-e1386455286656.png&#34; alt=&#34;Screen Shot 2013-12-08 at 7.26.53 AM&#34; width=&#34;500&#34; height=&#34;237&#34; class=&#34;alignnone size-full wp-image-307&#34; /&gt;&lt;br /&gt;
すると先ほどのデモ版と同様の画面が表示されるので、Step2でマスク領域を塗って、Step3で位置調整、合成という流れで遊んでください。&lt;br /&gt;
&lt;img src=&#34;http://localhost:1313/images/wp/blend_result.png&#34; alt=&#34;blend_result&#34; width=&#34;150&#34; height=&#34;150&#34; class=&#34;alignnone size-full wp-image-306&#34; /&gt;&lt;br /&gt;
こんな感じになります。&lt;del datetime=&#34;2013-12-07T16:12:47+00:00&#34;&gt;アゴ&lt;/del&gt;&lt;/p&gt;
&lt;p&gt;実際に顔写真でやってみるのが個人的には一番おもしろいと思います。&lt;/p&gt;
&lt;p&gt;あ、フッターみたいな変な所に結構重要なボタンがあります。最悪ですね。&lt;br /&gt;
&lt;img src=&#34;http://localhost:1313/images/wp/Screen-Shot-2013-12-08-at-2.23.06-AM.png&#34; alt=&#34;Screen Shot 2013-12-08 at 2.23.06 AM&#34; width=&#34;500&#34; height=&#34;351&#34; class=&#34;alignnone size-full wp-image-300&#34; /&gt;&lt;/p&gt;
&lt;h3&gt;Importing gradients と Mixing gradients&lt;/h3&gt;
&lt;p&gt;ここで無視していたStep1の話をしましょう。&lt;/p&gt;
&lt;p&gt;いい感じの画像合成では画像の勾配(Gradients)が大切です。画像における勾配とは、隣り合っているピクセル同士でRGB値がどれだけ違うかということ。&lt;br /&gt;
&lt;img src=&#34;http://localhost:1313/images/wp/blend_result.png&#34; alt=&#34;blend_result&#34; width=&#34;150&#34; height=&#34;150&#34; class=&#34;alignnone size-full wp-image-306&#34; /&gt;&lt;br /&gt;
先ほどの合成結果を見ると、&lt;strong&gt;色はベース画像に馴染みつつも、どこに線があるかという情報はソース画像のものを受け継いでいます&lt;/strong&gt;。このバランスがいい感じの合成を実現しているんですね。&lt;/p&gt;
&lt;p&gt;この線の情報（＝合成結果の勾配）の求め方は2通りあります。それが&lt;strong&gt;Importing gradients&lt;/strong&gt;と&lt;strong&gt;Mixing gradients&lt;/strong&gt;です。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Importing gradients&lt;/strong&gt;は先ほども例に挙げたように、ソース画像の勾配をそのまま合成結果に利用します。一方で&lt;strong&gt;Mixing gradients&lt;/strong&gt;は、各ピクセルに対してベース画像とソース画像の勾配を比較して大きい方を採用するというものです。&lt;/p&gt;
&lt;p&gt;これを切り替えて試せるのが、デモ版にもアプリ版にもあるStep1のラジオボタンです。さらにデモ版では&lt;strong&gt;Faces&lt;/strong&gt;と&lt;strong&gt;Hand&amp;amp;Sign&lt;/strong&gt;という2種類のベース画像・ソース画像の組み合わせを切り替え可能にしました。勾配の取り方2種類と画像セット2種類なので計4通りの合成を試すことができ、結果は以下のようになります。&lt;/p&gt;
&lt;table&gt;
&lt;tr&gt;
&lt;td&gt;&lt;/td&gt;
&lt;th&gt;Importing&lt;/th&gt;
&lt;th&gt;Mixing&lt;/th&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;th&gt;Faces&lt;/th&gt;
&lt;td&gt;&lt;img src=&#34;http://localhost:1313/images/wp/faces_importing.png&#34; alt=&#34;faces_importing&#34; width=&#34;150&#34; height=&#34;150&#34; class=&#34;alignnone size-full wp-image-301&#34; /&gt;&lt;/td&gt;
&lt;td&gt;&lt;img src=&#34;http://localhost:1313/images/wp/faces_mixing.png&#34; alt=&#34;faces_mixing&#34; width=&#34;150&#34; height=&#34;150&#34; class=&#34;alignnone size-full wp-image-302&#34; /&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;th&gt;Hand&amp;amp;Sign&lt;/th&gt;
&lt;td&gt;&lt;img src=&#34;http://localhost:1313/images/wp/hand_importing.png&#34; alt=&#34;hand_importing&#34; width=&#34;150&#34; height=&#34;150&#34; class=&#34;alignnone size-full wp-image-303&#34; /&gt;&lt;/td&gt;
&lt;td&gt;&lt;img src=&#34;http://localhost:1313/images/wp/hand_mixing.png&#34; alt=&#34;hand_mixing&#34; width=&#34;150&#34; height=&#34;150&#34; class=&#34;alignnone size-full wp-image-304&#34; /&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;/table&gt;
&lt;p&gt;見ての通り、Facesの場合はImportingのほうが期待通りの結果になっています。一方Hand&amp;amp;Signでは、Mixingのほうが手のシワを残しつつ文字を合成していて綺麗な結果になっています。&lt;strong&gt;文字上では手のシワよりも文字の勾配のほうが大きく、その他の部分は変化の少ない白い紙の写真なので手のシワの勾配のほうが大きかった&lt;/strong&gt;というわけです。&lt;/p&gt;
&lt;p&gt;ImportingとMixingのどちらが良いのかは一概に言うことはできず、合成する画像の組み合わせによって勾配の取り方も適切な方を使う必要があるんですね。&lt;/p&gt;
&lt;h3&gt;Poisson Image Editing&lt;/h3&gt;
&lt;p&gt;さて、そろそろ今回の画像合成手法をちゃんと紹介しましょう。&lt;br /&gt;
（トップダウン式な記事で我ながらすばらですね）&lt;/p&gt;
&lt;p&gt;今回利用している手法は&lt;strong&gt;Poisson Image Editing&lt;/strong&gt;というタイトルの、「ポアソン方程式を解くことで画像補間をいい感じにできるよ」という内容の論文で提案されているものです。PDFは以下より。&lt;/p&gt;
&lt;pre&gt;P. Pérez, M. Gangnet, A. Blake. &lt;strong&gt;&lt;a href=&#34;http://xeds.eu/clone/poisson.pdf&#34;&gt;Poisson Image Editing&lt;/a&gt;&lt;/strong&gt;. ACM Transactions on Graphics (SIGGRAPH&#39;03), 22(3):313-318, 2003.&lt;/pre&gt;
&lt;p&gt;いい感じの画像補完の具体例が今回実装したシームレスな画像合成で、これは論文の2章と3章にあたります。式の導出から書こうと思いましたがイマイチ自身無いのと実装で力尽きたのとでやめました。気になった方は原文読んで下さい。&lt;/p&gt;
&lt;p&gt;結論だけ書くと、論文内の式(7)を\(f_p=\)の形に変形して解けば終わりです。すなわち、すべての\(p \in \Omega\)に対して以下の式が成り立つような連立一次方程式を解くと言う問題。&lt;/p&gt;
&lt;p&gt;\[&lt;br /&gt;
f_p = \frac{\displaystyle \sum_{q \in N_p \cap \Omega}f_q + \sum_{q \in N_p \cap \partial \Omega}f^*_q + \sum_{q \in N_p}v_{pq}}{\displaystyle |N_p|}&lt;br /&gt;
\]&lt;/p&gt;
&lt;p&gt;この式の意味するところは論文中の図1なんかを参照しながらイメージするしかありません。無理やり言葉で説明するとだいたい以下のような雰囲気です。&lt;/p&gt;
&lt;p&gt;※&lt;strong&gt;ベース画像＝合成先&lt;/strong&gt;、&lt;strong&gt;ソース画像＝切り抜いて合成する方&lt;/strong&gt;です。&lt;/p&gt;
&lt;dl&gt;
&lt;dt&gt;\(\Omega\)&lt;/dt&gt;
&lt;dd&gt;合成結果の中で、切り抜いたソース画像が合成された領域&lt;/dd&gt;
&lt;dt&gt;\(f_p\)&lt;/dt&gt;
&lt;dd&gt;ある点\(p \in \Omega\)での\(f\)の値で、&lt;strong&gt;これを求めることが今回の目標&lt;/strong&gt;&lt;br /&gt;\(f\)は\(\Omega\)内の各ピクセルのRGB値を示す関数&lt;/dd&gt;
&lt;dt&gt;\(f^*_p\)&lt;/dt&gt;
&lt;dd&gt;ある点\(p\)での\(f^*\)の値&lt;br /&gt;\(f^*\)はベース画像内の各ピクセルのRGB値を示す関数（既知）&lt;/dd&gt;
&lt;dt&gt;\(N_p\)&lt;/dt&gt;
&lt;dd&gt;ある点\(p\)の近傍点の集合（今回はその点の上下左右、4近傍）&lt;/dd&gt;
&lt;dt&gt;\(\partial \Omega\)&lt;/dt&gt;
&lt;dd&gt;\(\Omega\)の境界領域&lt;br /&gt;\(p \not\in \Omega\)を満たす点のうち、近傍点が1つでも領域\(\Omega\)に入っていれば\(p \in \partial \Omega\)&lt;br /&gt;&lt;strong&gt;自分自身は入っていないけど近傍点のどれかは入っている&lt;/strong&gt;という状態&lt;/dd&gt;
&lt;dt&gt;\(g_p\)&lt;/dt&gt;
&lt;dd&gt;ソース画像からマスクをかけて切り抜いた部分の中にある点\(p\)でのRGB値&lt;/dd&gt;
&lt;dt&gt;\(v_{pq}\)&lt;/dt&gt;
&lt;dd&gt;ある点\(p\)とその近傍点のうちの1つ\(q\)の間の勾配&lt;br /&gt;&lt;strong&gt;Importing&lt;/strong&gt; \(g_p-g_q\)&lt;br /&gt;&lt;strong&gt;Mixing&lt;/strong&gt; ベース画像の勾配の方が大きければ\(f^*_p-f^*_q\), そうじゃなければ\(g_p-g_q\)&lt;/dd&gt;
&lt;/dl&gt;
&lt;p&gt;これに沿って実際に合成を行っている（＝\(f_p\)を求めている）コードは、ざっくりと流れを追うと以下のような感じ。&lt;/p&gt;
&lt;pre class=&#34;prettyprint lang-js&#34;&gt;
do {
  // 全ピクセルを見る 今回は簡単のため画像の端のピクセルは考慮しない
  for(var y=1; y&amp;lt;base_size.height-1; y++) {
    for(var x=1; x&amp;lt;base_size.width-1; x++) {
      if(/* もしStep2で塗ったマスク領域の中なら合成後のRGB値を推定 */) {

        // そのピクセルのRGB各色について連立一次方程式を解く
        for(var rgb=0; rgb&amp;lt;3; rgb++) {
          var sum_fq = 0;       // (1)
          var sum_boundary = 0; // (2)
          var sum_vpq = 0;      // (3)

          // 近傍点（4点）それぞれについて
          for(var i=0; i&amp;lt;num_neighbors; i++) {

            if(/* もし近傍点がStep2で塗ったマスク領域の中なら */) {
              // (1)の加算
            } else { // 近傍点は境界領域の中
              // (2)の加算
            }

            if(/* Mixingで、ベース画像の勾配の方が大きければ */) {
              // (3)の加算（ベース画像の勾配）
            } else {
              // (3)の加算（ソース画像の勾配）
            }
          }
          // そのピクセルのRGB推定値の格納
        }
      }
    }
  }
  if(/* 全ピクセルの推定が終わったので収束判定 */) break;
} while(true);
&lt;/pre&gt;
&lt;p&gt;&lt;a href=&#34;https://github.com/takuti/poisson-image-blending&#34;&gt;takuti / poisson-image-blending&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;(1)〜(3)は先に示した\(f_p = \)の式の右辺、分子の3つ項に対応します。&lt;/p&gt;
&lt;dl&gt;
&lt;dt&gt;(1)&lt;/dt&gt;
&lt;dd&gt;\(\displaystyle \sum_{q \in N_p \cap \Omega}f_q\)&lt;/dd&gt;
&lt;dt&gt;(2)&lt;/dt&gt;
&lt;dd&gt;\(\displaystyle \sum_{q \in N_p \cap \partial \Omega}f^*_q\)&lt;/dd&gt;
&lt;dt&gt;(3)&lt;/dt&gt;
&lt;dd&gt;\(\displaystyle \sum_{q \in N_p}v_{pq}\)&lt;/dd&gt;
&lt;/dl&gt;
&lt;p&gt;今、すべての\(p \in \Omega\)に対して\(f_p\)を求めているため、連立一次方程式の未知数（＝合成される領域内の点の数）は\(|\Omega|\)です。\(|\Omega|\)個の未知の点を順番に推定していくことになりますが、推定途中でも(1)では\(f\)の値を利用しています。&lt;/p&gt;
&lt;p&gt;このような、&lt;strong&gt;連立一次方程式の解の推定途中で推定済みの値とまだ推定されていない（過去の）値の両方を計算に利用する形&lt;/strong&gt;は、ガウスサイデル法の漸化式そのままです。そこで上記簡易コードではガウスサイデル法による解の推定を行っており、推定値の収束を合成の終了としています。&lt;/p&gt;
&lt;p&gt;合成の軸になる処理はこのようなシンプルな数値計算で完結します。しかし実際はCanvasの操作なんかでコードの肥大化が深刻。&lt;/p&gt;
&lt;h3&gt;まとめ&lt;/h3&gt;
&lt;p&gt;というわけで、Poisson Image Editingという論文で提案されたシームレスな画像合成をCanvasとJavaScriptで実装してみて、おまけにアプリ版も作ってみたお話でした。&lt;/p&gt;
&lt;p&gt;実は以前この手法の画像合成を試したことがあったのですが、なぜかうまくいかず詰んだので放置していました。しかし再挑戦したらなんとかなった。これは今期履修している数値解析のおかげかな！？（申し訳程度の会津大要素）&lt;/p&gt;
&lt;p&gt;アプリ版はまた気が向いた頃に実装の見直しや改善をするかもしれません。&lt;/p&gt;
&lt;p&gt;とりあえず今はこの記事を書き上げたことでようやくBDFS始められるので僕は消えます。&lt;/p&gt;
&lt;div class=&#34;kaerebalink-box&#34; style=&#34;text-align:left;padding-bottom:20px;font-size:small;/zoom: 1;overflow: hidden;&#34;&gt;
&lt;div class=&#34;kaerebalink-image&#34; style=&#34;float:left;margin:0 15px 10px 0;&#34;&gt;&lt;a href=&#34;http://www.amazon.co.jp/exec/obidos/ASIN/B00EVN4T40/takuti-22/ref=nosim/&#34; rel=&#34;nofollow&#34; target=&#34;_blank&#34;&gt;&lt;img src=&#34;http://ecx.images-amazon.com/images/I/61wNv9RM0UL._SL160_.jpg&#34; style=&#34;border: none;&#34; /&gt;&lt;/a&gt;&lt;/div&gt;
&lt;div class=&#34;kaerebalink-info&#34; style=&#34;line-height:120%;/zoom: 1;overflow: hidden;&#34;&gt;
&lt;div class=&#34;kaerebalink-name&#34; style=&#34;margin-bottom:10px;line-height:120%&#34;&gt;&lt;a href=&#34;http://www.amazon.co.jp/exec/obidos/ASIN/B00EVN4T40/takuti-22/ref=nosim/&#34; rel=&#34;nofollow&#34; target=&#34;_blank&#34;&gt;ブレイブリーデフォルト フォーザ・シークウェル&lt;/a&gt;
&lt;div class=&#34;kaerebalink-powered-date&#34; style=&#34;font-size:8pt;margin-top:5px;font-family:verdana;line-height:120%&#34;&gt;posted with &lt;a href=&#34;http://kaereba.com&#34; rel=&#34;nofollow&#34; target=&#34;_blank&#34;&gt;カエレバ&lt;/a&gt;&lt;/div&gt;
&lt;/div&gt;
&lt;div class=&#34;kaerebalink-detail&#34; style=&#34;margin-bottom:5px;&#34;&gt; スクウェア・エニックス 2013-12-05    &lt;/div&gt;
&lt;div class=&#34;kaerebalink-link1&#34; style=&#34;margin-top:10px;&#34;&gt;
&lt;div class=&#34;shoplinkamazon&#34; style=&#34;display:inline;margin-right:5px&#34;&gt;&lt;a href=&#34;http://www.amazon.co.jp/gp/search?keywords=%83u%83%8C%83C%83u%83%8A%81%5B%83f%83t%83H%83%8B%83g%20%83t%83H%81%5B%83U&amp;__mk_ja_JP=%83J%83%5E%83J%83i&amp;tag=takuti-22&#34; rel=&#34;nofollow&#34; target=&#34;_blank&#34; title=&#34;アマゾン&#34; &gt;Amazon&lt;/a&gt;&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class=&#34;booklink-footer&#34; style=&#34;clear: left&#34;&gt;&lt;/div&gt;
&lt;/div&gt;
&lt;p&gt;明日、&lt;a href=&#34;http://atnd.org/events/45075&#34;&gt;Aizu Advent Calendar 2013&lt;/a&gt; 9日目の担当は&lt;a href=&#34;http://twitter.com/WinField95&#34;&gt;95さん&lt;/a&gt;です！しゃす！&lt;/p&gt;
&lt;p&gt;&lt;a href=&#34;http://araraak.hatenadiary.jp/&#34;&gt;影で就活Advent Calendarやってる人&lt;/a&gt;がいるのでよかったらそちらも見てあげて下さい。&lt;/p&gt;
&lt;h3&gt;参考&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;http://opencv.jp/opencv2-x-samples/poisson-blending&#34;&gt;Poisson Blending | OpenCV.jp&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://d.hatena.ne.jp/mscp/20081130/1261916214&#34;&gt;Poisson Image Editing - ますぽんの雑記&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://akita-nct.jp/yamamoto/lecture/2006/5E/Linear_eauations/concrete_relax_html/node2.html&#34;&gt;2 ガウス・ザイデル法を使った計算&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://www.html5rocks.com/ja/tutorials/file/dndfiles/&#34;&gt;JavaScript でのローカル ファイルの読み込み - HTML5 Rocks&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://jsdo.it/Yukisuke/p311&#34;&gt;Canvasの画像(スクリーンショット)をローカルダウンロードします。 - jsdo.it - Share JavaScript, HTML5 and CSS&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
</description>
    </item>
    
    <item>
      <title>HTML5 CanvasでメルトPVに出てくるメル時計をつくった</title>
      <link>http://localhost:1313/note/meltokei/</link>
      <pubDate>Sun, 04 Aug 2013 00:00:00 +0000</pubDate>
      
      <guid>http://localhost:1313/note/meltokei/</guid>
      <description>&lt;p&gt;メルトといえばあのメルトです。恋に落ちる音がするやつです。冬に売ってる雪のような口どけのやつじゃないです。&lt;/p&gt;
&lt;p&gt;そのPVに、以下のようなものがあります。&lt;/p&gt;
&lt;p&gt;&lt;script type=&#34;text/javascript&#34; src=&#34;http://ext.nicovideo.jp/thumb_watch/sm2671946&#34;&gt;&lt;/script&gt;&lt;br /&gt;
&lt;noscript&gt;&lt;a href=&#34;http://www.nicovideo.jp/watch/sm2671946&#34;&gt;【ニコニコ動画】メルトPV　shortバージョン（完成版）&lt;/a&gt;&lt;/noscript&gt;&lt;/p&gt;
&lt;p&gt;素敵ですね。&lt;/p&gt;
&lt;p&gt;このPVに出てくる時計が可愛いということで、アップロードされた当時は&lt;strong&gt;メル時計&lt;/strong&gt;なんて呼ばれて、&lt;a href=&#34;http://www.nicovideo.jp/watch/sm2146274&#34;&gt;実際に作ってみた人&lt;/a&gt;や&lt;a href=&#34;http://www.nicovideo.jp/watch/sm2694098&#34;&gt;Windows Vistaのサイドバーガジェットにした人&lt;/a&gt;、&lt;a href=&#34;http://www.nicovideo.jp/watch/sm2694098&#34;&gt;Flashで作った人&lt;/a&gt;なんかが現れたのは記憶に新し・・・くはないけれど、今でもよく覚えています。&lt;/p&gt;
&lt;p&gt;ふとHTML5 Canvasで何か作りたいなーと思って思い浮かんだのがこのメル時計だったので早速作ってみました。完成品は以下より。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;a href=&#34;http://takuti.me/dev/meltokei/&#34;&gt;メル時計&lt;/a&gt;&lt;/strong&gt;&lt;br /&gt;
&lt;img src=&#34;http://localhost:1313/images/wp/meltokei.png&#34; alt=&#34;meltokei&#34; width=&#34;428&#34; height=&#34;420&#34; class=&#34;alignnone size-full wp-image-236&#34; /&gt;&lt;br /&gt;
&lt;!--more--&gt;&lt;br /&gt;
秒針もつけました。いいかんじ。&lt;/p&gt;
&lt;p&gt;PVの時計のシーンを見ながら作って、サイズはそのままに、色もMacに標準で入っているカラーピッカー &lt;strong&gt;DigitalColor Meter&lt;/strong&gt; を使ってできる限り再現したつもりです。もちろん画像は使ってません。&lt;/p&gt;
&lt;p&gt;PVでは左上から光が当たっているので影を付けたかったのですが、あまり綺麗にならなかったのでそれはボツ。&lt;/p&gt;
&lt;p&gt;実装に関しては、&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;背景色でCanvas全体を塗りつぶし&lt;/li&gt;
&lt;li&gt;時計の円を色ごとに外側から順番に描画&lt;/li&gt;
&lt;li&gt;文字盤代わりの六角形たちを描画&lt;/li&gt;
&lt;li&gt;現在の時刻からそれぞれの針の角度を求めて描画&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;を1秒間隔でやり続けるだけです。&lt;/p&gt;
&lt;p&gt;基本的にはただひたすらarcとかfillとかやればいいだけなので簡単ですが、Canvasビギナーの僕には回転 &lt;strong&gt;rotate()&lt;/strong&gt; の扱い方と、長針・短針の角丸化が少しだけ厄介でした。勉強になった。&lt;/p&gt;
&lt;p&gt;これについては別記事でメモとして書きます。&lt;br /&gt;
&lt;a href=&#34;http://blog.takuti.me/canvas-rotate-round/&#34;&gt;HTML5 Canvasの回転と角丸についてメモ&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;PV確認のついでにメルトを聴いてちょっと懐かしい気持ちになり、投稿日を確認したらもう5年も前で驚きを隠せなかった僕でした。おわり。&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>HTML5 Canvasの回転と角丸についてメモ</title>
      <link>http://localhost:1313/note/canvas-rotate-round/</link>
      <pubDate>Sat, 03 Aug 2013 00:00:00 +0000</pubDate>
      
      <guid>http://localhost:1313/note/canvas-rotate-round/</guid>
      <description>&lt;p&gt;&lt;a href=&#34;http://blog.takuti.me/meltokei/&#34;&gt;HTML5 CanvasでメルトPVに出てくるメル時計をつくった&lt;/a&gt;で、ビギナーの僕には少し厄介だった回転と角丸化についてメモメモ。&lt;br /&gt;
&lt;!--more--&gt;&lt;/p&gt;
&lt;h3&gt;回転 rotate() の扱い方&lt;/h3&gt;
&lt;p&gt;&lt;a href=&#34;http://takuti.me/dev/meltokei/&#34;&gt;メル時計&lt;/a&gt;の文字盤代わりの六角形は、12時の位置に全ての時刻分を（色を変えながら）作りつつ、それらを30°ずつ回転させていくことで描画しました。&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;http://localhost:1313/images/wp/hexagon.png&#34; alt=&#34;hexagon&#34; width=&#34;202&#34; height=&#34;144&#34; class=&#34;alignnone size-full wp-image-237&#34; /&gt;&lt;br /&gt;
1：てっぺんをスタートして右に8px、下に10pxの移動&lt;br /&gt;
2：下に18pxの移動&lt;br /&gt;
3：2の移動した先から、更に下に3px移動したところが、もう1つの六角形のてっぺん&lt;/p&gt;
&lt;p&gt;この3つさえ分かればあとは対称だったりするので、とりあえず12時の位置に色を変えながら量産することは問題なくできます。あとは30°ずつ回転をさせるだけです。&lt;/p&gt;
&lt;p&gt;しかし、&lt;strong&gt;rotate()&lt;/strong&gt;はcanvasそのものの左上を中心とみて回転させるので、ふつうに&lt;strong&gt;rotate(Math.PI/6)&lt;/strong&gt;とかやっても思うように回ってくれません。円（時計）の中心を回転の中心にしてほしい！&lt;/p&gt;
&lt;p&gt;そんなときは、「現時点でのcanvasそのものの左上を円の中心にズラしてから回転させる。回転が終わったらズラした分を元に戻す。」という方法をとるみたいです。&lt;/p&gt;
&lt;p&gt;【参考】&lt;a href=&#34;http://tech.kayac.com/archive/canvas-tutorial.html&#34;&gt;今更聞けないcanvasの基礎の基礎 | tech.kayac.com - KAYAC engineers&#39; blog&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;つまり、canvas全体を回転の中心にしたい座標（今回は400x400のcanvasに描画した半径200の円の中心なので(200,200)）の分だけ移動して、本来回転させたかった角度で回転させたら、移動させた分を元に戻す、と。&lt;/p&gt;
&lt;pre class=&#34;prettyprint lang-js&#34;&gt;
ctx.translate(200,200);
ctx.rotate(30*Math.PI/180);
ctx.translate(-200,-200);
&lt;/pre&gt;
&lt;p&gt;デキター！&lt;/p&gt;
&lt;p&gt;ちなみに、&lt;strong&gt;rotate()&lt;/strong&gt;の状態を解除する方法も分からなくて悲しみました。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;rotate(θ)&lt;/strong&gt;をした後に何もしないと、以後の描画処理が全て角度θだけ回転した状態で行われてしまうんですね。だから、もう回転の必要がなくなったらそれを解除して、全く回転していない状態に戻してあげる必要があるというわけなんだとか。&lt;/p&gt;
&lt;p&gt;そこでよく使われるのが&lt;strong&gt;save()&lt;/strong&gt;と&lt;strong&gt;restore()&lt;/strong&gt;で、これらを使うと描画状態（回転情報も含んでいる&lt;strong&gt;変換行列&lt;/strong&gt;など）を保存して、復元することができる。&lt;/p&gt;
&lt;p&gt;全く回転していない状態を&lt;strong&gt;save()&lt;/strong&gt;して、回転の必要がなくなったところですぐ&lt;strong&gt;restore()&lt;/strong&gt;してあげれば、その後もイメージどおりに描画できるんですね！&lt;/p&gt;
&lt;pre class=&#34;prettyprint lang-js&#34;&gt;
ctx.save(); // 変換行列の初期状態（全く回転していない状態）を保存

rotateSomething(); // 回転を含む処理

// 回転を含む処理の後には必ず変換行列を初期状態に戻し、再度保存しておく
ctx.restore();
ctx.save();
&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;save()&lt;/strong&gt;と&lt;strong&gt;restore()&lt;/strong&gt;はスタックのPushとPopに対応するので、一度&lt;strong&gt;restore()&lt;/strong&gt;をしてしまうとせっかく保存していた初期状態の情報が消えてしまいます。そのため、&lt;strong&gt;restore()&lt;/strong&gt;の直後にもう一度&lt;strong&gt;save()&lt;/strong&gt;をして、次の回転を含む処理に備えます。&lt;/p&gt;
&lt;p&gt;というわけで、移動させてから回転させてまた戻すことと、回転した状態を解除することによって、イメージ通りの回転を含む描画処理いろいろができました。&lt;/p&gt;
&lt;h3&gt;角丸な長方形&lt;/h3&gt;
&lt;p&gt;長方形を角丸にしたい場面はたくさんあるのに、Canvasではササッと角丸な長方形を作ってくれる機能などありません。&lt;/p&gt;
&lt;p&gt;そこで、角丸長方形は1/4の円弧を4つ描いてそれらを結ぶことによって実現します。&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;http://localhost:1313/images/wp/Screen-Shot-2013-08-04-at-12.19.25-PM.png&#34; alt=&#34;Screen Shot 2013-08-04 at 12.19.25 PM&#34; width=&#34;130&#34; height=&#34;130&#34; class=&#34;alignnone size-full wp-image-239&#34; /&gt;&lt;br /&gt;
これは円弧ひとつひとつに対して&lt;strong&gt;beginPath()&lt;/strong&gt;,&lt;strong&gt;stroke()&lt;/strong&gt;をしたもの。&lt;/p&gt;
&lt;p&gt;これを、&lt;strong&gt;beginPath()&lt;/strong&gt;を最初に一度だけ行い、円弧すべての&lt;strong&gt;arc()&lt;/strong&gt;を実行した後に&lt;strong&gt;closePath()&lt;/strong&gt;をしてあげるようにすれば、あとは&lt;strong&gt;stroke()&lt;/strong&gt;なり&lt;strong&gt;fill()&lt;/strong&gt;なりでお好みの角丸な長方形ができあがる。&lt;/p&gt;
&lt;p&gt;長方形の位置や幅、高さは4つの円弧の中心点に依存するわけですね。&lt;/p&gt;
&lt;p&gt;これについては、以下を参考にさせていただき解釈しました。&lt;br /&gt;
&lt;a href=&#34;http://devlabo.blogspot.jp/2010/03/javascriptcanvas.html&#34;&gt;[javascript]canvasで円や角丸の矩形を描画する&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;以上、回転と角丸についてのメモでした。&lt;/p&gt;
</description>
    </item>
    
  </channel>
</rss>